// Generated by CoffeeScript 2.4.1
(function() {
  // #JSONMetadom: a simple HTML presentation system that supports local or client/server usage

  // JSONMetadom uses a JSON object to implement its own Document Object Model that you can share with your local JavaScipt code or with a server. JSONMetadom renders the JSON object in the browser using definitions you provide and it re-renders parts of the GUI when you change values in the JSON object. You can manage the model either in local JavaScript or on a server. JSONMetadom also binds parts of the JSON object and changes it when users interact with the GUI, transmitting those changes to the local JavaScript code or to the server.

  // JSONMetadom is engineered to be simple and lightweight, defined in roughly 500 lines of CoffeeScript.

  // #Overview

  // JSONMetadom chooses a "view" for each nested object in the JSON object you provide by using the object's "type" property. Views are defined using Handlebars, displaying with the JSON object as their context. JSONMetadom also supports namespaces for views, i.e. you can define different views on the same type for different contexts (an object could render as a form in one namespace and a list item in another namespace).

  // When the Javascript model (or server, if connected) changes some of JSONMetadom's JSON objects, it automatically rerenders the views for those objects.

  // JSONMetadom can bind values in its HTML views to paths in its JSON objects so that the HTML can display and/or change the values at thoses paths. When the user changes one of those values, JSONMetadom changes the JSON object at that path and sends an event to the Javascript model (or the server, if connected).

  // #Views

  // Views can also contain other views because JSONMetadom defines a "view" Handlebar plugin.

  // Views can contain elements with `data-path` attributes that specifying a
  // *path* to a property in the JSON object, example:

  // `<input type=text data-path="a.b.c">`

  // If an element has a non-null data-bind-keypress attribute, any keypresses that are not enter or return will be sent as "key" events to the Javascript model (or server, if connected).

  // An element is considered to be a button if it has a data-path property and it is either a non-input element, a button element, or a submit element. The behavior on the JSON object depends on its "value" attribute (if there is one):

  // * no value attribute: when you press the button, JSONMetadom does not change the JSON object but it sends a click event to the model (see Events, below)
  // * the value is a boolean: it acts as a checkbox and when you press it, JSONMetadom sets the boolean value in the JSON object and sends a "set" event (see Events, below)
  // * otherwise: when the input element changes (like by focusing out of a field), JSONMetadom sets the JSON path in the object to the value property, parsed as a JSON value (see Events, below)

  // #Main JSON object

  // views: {NAMESPACE: {TYPE: HANDLEBARSDEF}, ...}
  // type: top
  // content: [DATA, ...]

  // The main JSON object supplied to JSONMetadom can optionally provide

  // #Events
  // The Javascript model (or the server, if you are connecting to one) recieves events for clicks and sets with the JSON path and the new value, if there is one. The model (or server) can then change the JSON model in response to trigger an update on the screen, which re-renders the parts of the model that have changed.

  // #Viewdefs

  // You define views with viewdefs and this is normally in the HTML file by putting `data-viewdef` attributes in HTML elements. the value of the `data-viewdef` element can be:

  // - `TYPE`, where TYPE is any string value a JSON object might have in its `type` property
  // - `NAMESPACE/TYPE`, where namespace is any name you choose to make a namespace and TYPE is as above

  // You can use a namespace with the `view` Handlebars plugin (see below).

  // You can also define viewdefs in the `views` property of the main JSON object.

  // #The namespace type
  // The namespace type sets the namespace for its content object or array of objects, like this:

  // {"type": "namespace", "namespace": "bubba", "content": ...}

  // This will set the namespace to bubba for the content object or array of objects.

  // #The view plugin for Handlebars

  // The predefined `view` plugin lets you show a view on an object or array of objects and you can optionally set the namespace, like this:

  // {{{view `path.in.JSON.object`}}}

  // or

  // {{{view `path.in.JSON.object` `namespace-name`}}}

  // #Events
  // There are two types of events:

  // - set(path, value): the user changed something in the GUI that triggered a set event
  // - click(path, value): the user clicked a button, which can optionally include a value, depending on the view

  // #Using JSONMetadom

  // On the web side, you need to make sure the files in the js and css directories are available to your HTML file and include these elements (altered to fit your file layout, of course):

  // \<link rel="stylesheet" href="css/jsonmetadom.css">\</link>
  // \<script src="js/lib/handlebars-v4.0.5.js">\</script>
  // \<script src="js/jsonmetadom.js">\</script>

  // It's also compatible with AMD style so you can use something like require.js:

  // \<link rel="stylesheet" href="css/metadom.css">\</link>
  // \<script data-main="js/config" src="js/lib/require-2.1.18.js">\</script>

  // You can implement the model in local JavaScript or in a server. Metadom currently supports Julia servers.

  // #Connecting to a server
  // Put this at the bottom of the body of your web page, with the HOST and PORT of your server in it:

  // \<script>JSONMetadom.connect({}, "ws://HOST:PORT")\</script>

  // The Julia server code supports its own version of event handlers and DocPath (see the JavaScript model documentation below)

  // #Using JSONMetadom with a JavaScript model

  // * Create a Javascript object with
  // ```
  // {type: 'document',
  //  views: {default: {viewdefs...},
  //  NAMESPACE1: {viewdefs...}},
  //  contents: [CONTENTS...]}
  // ```

  // Views are optional in the object since they can also be in the HTML page.

  // - Create a context with {top: JSON, handler: HANDLER}
  //   - JSON is the JSON object you have created
  //   - HANDLER is an event handler
  //     - You can use the patternHandler() function to easily specify event handlers (see source for documentation).
  //     - Otherwise, the handler is {clickButton: (evt)=> ..., changedValue: (evt)=> ..., key: (evt)=> ...}
  //     - the dispatchClick, dispatchKey, and dispatchSet functions dispatch events in a high-level way, using DocPaths (see below)
  // ##DocPaths
  // A DocPath is proxy that makes it easy navigate paths in the JSON object and it lets you change the JSON object and automatically trigger re-rendering for those changes. It's called DocPath because the JSON object is the "document" of the Document Object Model. PatternHandler and the three dispatch functions (dispatchClick, dispatchKey, and dispatchSet) each send a DocPath as the first argument to your provided event handler function.

  // Given docp is a DocPath...

  // - `docp.PROP` returns the value in the document at PROP if it is atomic or, if the value is an array or object, it returns a new DocPath for that location (with docp's path extended to include PROP)
  // - `docp[INDEX]` returns the value in the document at INDEX if it is atomic or, if the value is an array or object, it returns a new DocPath for that location (with docp's path extended to include INDEX)
  // - `docPathValue(docp)` returns docp's value
  // - `docp.PROP = VALUE` sets the value in the document and cause JSONMetadom to re-render it
  // - `docPathParts(docp)` returns the "parts" of a DocPath, the JSONMetadom object, the context, and the path array

  // You can use `batch(con, func)` if you need to change DocPaths outside of an event handler for "event compression". Batch eliminates re-rendering of the same object multiple times.
  var define, ref,
    indexOf = [].indexOf;

  define = (ref = window.define) != null ? ref : function(n, func) {
    return window.JSONMetadom = func(window.Handlebars);
  };

  define(['handlebars'], function(Handlebars) {
    var JSONMetadom, batch, change, closestLocation, compile, connect, curId, dispatchClick, dispatchKey, dispatchSet, docPath, docPathParent, docPathParts, docPathValue, docValue, eventPaths, find, findIds, globalContext, handleChanges, handleMessage, initChangeContext, isDocPath, isDocPathSym, keyCode, locationToString, messages, metadomBlur, metadomChange, metadomFocus, metadoms, nodeToTop, normalizePath, parseHtml, parsingDiv, partsSym, patternHandler, query, queryAll, registerHelper, replace, resolvePath, stringToLocation, syms;
    ({compile, registerHelper} = Handlebars);
    curId = 0;
    keyCode = function(evt) {
      var key, ref1;
      if (!((ref1 = evt.key.toLowerCase()) === 'shift' || ref1 === 'control' || ref1 === 'alt')) {
        key = evt.key;
        if (key.toLowerCase().startsWith('arrow')) {
          key = key.slice(5).toLowerCase();
        }
        if (evt.shiftKey && key.length > 1) {
          key = "S-" + key;
        }
        if (evt.ctrlKey) {
          key = "C-" + key;
        }
        if (evt.altKey || evt.metaKey) {
          key = "M-" + key;
        }
        return key;
      }
    };
    nodeToTop = new WeakMap();
    parsingDiv = document.createElement('div');
    query = document.querySelector.bind(document);
    queryAll = document.querySelectorAll.bind(document);
    find = function(node, selector) {
      return node.querySelectorAll(selector);
    };
    parseHtml = function(str) {
      var dom;
      parsingDiv.innerHTML = `<div>${str}</div>`;
      dom = parsingDiv.firstChild;
      parsingDiv.innerHTML = '';
      if (dom.childNodes.length === 1 && dom.firstChild.nodeType === 1) {
        return dom.firstChild;
      } else {
        return dom;
      }
    };
    locationToString = function(loc) {
      var coord, l, len, str;
      str = "";
      for (l = 0, len = loc.length; l < len; l++) {
        coord = loc[l];
        if (str) {
          str += " ";
        }
        str += coord;
      }
      return str;
    };
    stringToLocation = function(str) {
      var coord, l, len, ref1, results;
      ref1 = str.split(' ');
      results = [];
      for (l = 0, len = ref1.length; l < len; l++) {
        coord = ref1[l];
        results.push(String(Number(coord)) === coord ? Number(coord) : coord);
      }
      return results;
    };
    resolvePath = function(doc, location) {
      var first, j, parent, path;
      if (typeof location === 'string') {
        [j, path, parent] = doc.index[location];
        location = path;
      }
      if (typeof location[0] === 'string' && location[0][0] === '@') {
        first = location[0].slice(1);
        [j, path, parent] = doc.index[first];
        location = location.length > 1 ? [...path, ...location.slice(1)] : path;
      }
      return location;
    };
    normalizePath = function(path, index) {
      var ignore;
      if (Array.isArray(path)) {
        return path;
      } else {
        [ignore, path] = index[typeof path === 'object' ? path.id : path];
        return path;
      }
    };
    findIds = function(parent, json, ids = {}, location = []) {
      var el, i, k, l, len, v;
      if (Array.isArray(json)) {
        for (i = l = 0, len = json.length; l < len; i = ++l) {
          el = json[i];
          findIds(json, el, ids, [...location, i]);
        }
      } else if (json !== null && typeof json === 'object') {
        if (json.type != null) {
          if (json.id == null) {
            json.id = ++curId;
            json.__assignedID = true;
          }
          ids[json.id] = [json, location, parent];
        }
        for (k in json) {
          v = json[k];
          findIds(json, v, ids, [...location, k]);
        }
      }
      return ids;
    };
    closestLocation = function(node) {
      return node.closest('[data-location]').getAttribute('data-location');
    };
    globalContext = {
      namespace: 'default'
    };
    replace = function(oldDom, newDom) {
      var l, len, n, na, nav, ref1;
      // prefer mutating the old dom to replacing it
      if (oldDom && oldDom.nodeName === newDom.nodeName && oldDom.childNodes.length === 0 && newDom.childNodes.length === 0) {
        na = new Set(newDom.getAttributeNames());
        ref1 = oldDom.getAttributeNames();
        for (l = 0, len = ref1.length; l < len; l++) {
          n = ref1[l];
          if (!na.has(n)) {
            oldDom.removeAttribute(n);
          }
        }
        for (n in na) {
          nav = newDom.getAttribute(n);
          if (nav !== oldDom.getAttribute(n)) {
            oldDom.setAttribute(n, nav);
          }
        }
        return oldDom;
      } else {
        oldDom.replaceWith(newDom);
        return newDom;
      }
    };
    metadoms = [];
    metadomBlur = function(event) {
      var l, len, md, results;
      results = [];
      for (l = 0, len = metadoms.length; l < len; l++) {
        md = metadoms[l];
        if (event.target.nodeType === 1 && md.top.contains(event.target)) {
          results.push(md.blurring = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    metadomFocus = function(event) {
      var l, len, md, results;
      results = [];
      for (l = 0, len = metadoms.length; l < len; l++) {
        md = metadoms[l];
        if (md.blurring) {
          md.blurring = false;
          results.push(md.runRefreshQueue());
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    metadomChange = function(event) {};
    JSONMetadom = class JSONMetadom {
      constructor(top1) {
        this.top = top1;
        if (!this.top) {
          throw new Error("No top node for JSONMetadom");
        }
        this.refreshQueue = []; // queued refresh commands that execute after the current event
        this.specialTypes = {
          document: (dom, json, context) => {
            return this.renderTop(dom, json, context);
          },
          namespace: (dom, json, context) => {
            return this.renderNamespace(dom, json, context);
          }
        };
        if (!metadoms.length) {
          window.addEventListener("blur", metadomBlur, true);
          window.addEventListener("focus", metadomFocus, true);
          window.addEventListener("change", metadomChange, true);
        }
        metadoms.push(this);
      }

      // Find view for json and replace dom with the rendered view. Context contains global info like the
      // current namespace, etc.
      render(dom, json, context) {
        var newDom;
        if (context.views == null) {
          context.views = {};
        }
        newDom = this.baseRender(dom, json, Object.assign({
          location: []
        }, context));
        this.analyzeInputs(newDom, context);
        return newDom;
      }

      baseRender(dom, json, context) {
        var childDom, el, i, id, l, len, newDom, ref1, ref2, special;
        context = Object.assign({}, globalContext, context);
        id = (ref1 = (ref2 = json.id) != null ? ref2 : dom.getAttribute('id')) != null ? ref1 : ++curId;
        dom.setAttribute('id', id);
        if (Array.isArray(json)) {
          newDom = parseHtml(`<div data-location='${locationToString(context.location)}'></div>`);
          newDom.setAttribute('id', id);
          dom.replaceWith(newDom);
          for (i = l = 0, len = json.length; l < len; i = ++l) {
            childDom = json[i];
            el = parseHtml('<div></div>');
            newDom.appendChild(el);
            this.baseRender(el, childDom, Object.assign({}, context, {
              location: [...context.location, i]
            }));
          }
          return newDom;
        } else if (special = this.specialTypes[json.type]) {
          return special(dom, json, context);
        } else {
          return this.normalRender(dom, json, context);
        }
      }

      // special renderers can use this to modify how their views render
      normalRender(dom, json, context) {
        var def, newDom, old;
        def = this.findViewdef(json.type, context);
        newDom = parseHtml((function() {
          if (def) {
            try {
              old = globalContext;
              globalContext = context;
              return def(json, {
                data: Object.assign({
                  metadom: this
                }, {context})
              });
            } finally {
              globalContext = old;
            }
          } else {
            return `COULD NOT RENDER TYPE ${json.type}, NAMESPACE ${context.namespace}`;
          }
        }).call(this));
        newDom.setAttribute('data-location', locationToString(context.location));
        newDom.setAttribute('data-namespace', context.namespace);
        newDom.setAttribute('id', json.id);
        newDom = replace(dom, newDom);
        this.populateInputs(newDom, json, context);
        return newDom;
      }

      findViewdef(type, context) {
        var def, domClone, el, namespace, ref1, ref2, ref3, ref4;
        if (def = ((ref1 = context.views) != null ? (ref2 = ref1[context.namespace]) != null ? ref2[type] : void 0 : void 0) || ((ref3 = context.views) != null ? (ref4 = ref3.default) != null ? ref4[type] : void 0 : void 0)) {
          return def;
        }
        if (el = query(`[data-viewdef='${context.namespace}/${type}']`)) {
          namespace = context.namespace;
        } else if (!(el = query(`[data-viewdef='${type}']`))) {
          return;
        }
        if (context.views == null) {
          context.views = {};
        }
        if (context.views[namespace] == null) {
          context.views[namespace] = {};
        }
        domClone = el.cloneNode(true);
        domClone.removeAttribute('data-viewdef');
        return context.views[namespace][type] = compile(domClone.outerHTML);
      }

      rerender(json, context, thenBlock) {
        return this.queueRefresh(() => {
          var l, len, newDom, node, oldDom, ref1, top;
          oldDom = query(`[id='${json.id}']`);
          context = Object.assign({}, context, {
            location: stringToLocation(oldDom.getAttribute('data-location'))
          });
          if (oldDom.getAttribute('data-namespace')) {
            context.namespace = oldDom.getAttribute('data-namespace');
          }
          newDom = this.render(query(`[id='${json.id}']`), json, context);
          top = newDom.closest('[data-top]');
          ref1 = find(newDom, '[data-path-full]');
          for (l = 0, len = ref1.length; l < len; l++) {
            node = ref1[l];
            this.valueChanged(top, node);
          }
          return thenBlock(newDom);
        });
      }

      renderTop(dom, json, context) {
        var base, base1, contents, def, namespace, newDom, type, types, views;
        ({views, contents} = json);
        json.index = findIds(null, contents);
        json.compiledViews = {};
        if (context.views == null) {
          context.views = {};
        }
        for (namespace in views) {
          types = views[namespace];
          if ((base = json.compiledViews)[namespace] == null) {
            base[namespace] = {};
          }
          if ((base1 = context.views)[namespace] == null) {
            base1[namespace] = {};
          }
          for (type in types) {
            def = types[type];
            //destructively modify context's views
            context.views[namespace][type] = json.compiledViews[namespace][type] = compile(def);
          }
        }
        newDom = this.baseRender(dom, contents, Object.assign(context, {
          top: json,
          location: []
        }));
        newDom.setAttribute('data-top', 'true');
        nodeToTop.set(newDom, context);
        return newDom;
      }

      renderNamespace(dom, json, context) {
        if (!json.namespace) {
          throw new Error(`No namespace in namespace element ${JSON.stringify(json)}`);
        }
        return this.baseRender(dom, json.content, Object.assign({}, context, {
          namespace: json.namespace,
          location: [...context.location, "content"]
        }));
      }

      queueRefresh(cmd) {
        this.refreshQueue.push(cmd);
        if (!this.pressed && !this.blurring && document.activeElement !== document.body) {
          return this.runRefreshQueue();
        }
      }

      runRefreshQueue() {
        var q;
        if (this.refreshQueue.length > 0) {
          q = this.refreshQueue;
          this.refreshQueue = [];
          return setTimeout((function() {
            var activeInput, cmd, index, input, l, len, results;
            results = [];
            for (l = 0, len = q.length; l < len; l++) {
              cmd = q[l];
              // TODO this selects even if the focus event was a mouse click instead of a tab
              if (activeInput = document.activeElement.getAttribute('data-path-full')) {
                index = Array.prototype.slice.call(queryAll(`[data-path-full='${activeInput}']`)).indexOf(document.activeElement);
              }
              cmd();
              if (activeInput && (input = queryAll(`[data-path-full='${activeInput}']`)[index])) {
                input.focus();
                results.push(typeof input.select === "function" ? input.select() : void 0);
              } else {
                results.push(void 0);
              }
            }
            return results;
          }), 5);
        }
      }

      addSpecialType(typeName, func) {
        return this.specialTypes[typeName] = func;
      }

      replace(top, path, json, context) {
        var index, l, len, location, namespace, oldJson, parent, property;
        if (!context) {
          context = json;
          json = path;
          path = {
            id: json.id
          };
        }
        if (!(index = top.index)) {
          index = top.index = {};
        }
        context = Object.assign({
          views: top.compiledViews,
          top: top
        }, context);
        namespace = 'default';
        path = normalizePath(path, index);
        oldJson = top.contents;
        parent = oldJson;
        property = null;
        for (l = 0, len = path.length; l < len; l++) {
          location = path[l];
          parent = oldJson;
          oldJson = oldJson[location];
        }
        parent[location[location.length - 1]] = oldJson;
        if (oldJson.id) {
          json.id = oldJson.id;
        }
        this.adjustIndex(index, parent, oldJson, json);
        context.location = path;
        return this.rerender(json, context, function() {});
      }

      adjustIndex(index, parent, oldJson, newJson) {
        var k, newIds, oldIds, oldKeys, results, v;
        oldIds = findIds(parent, oldJson);
        newIds = findIds(parent, newJson);
        oldKeys = new Set(Object.keys(oldIds));
        for (k in newIds) {
          v = newIds[k];
          if (v[1].length === 0) {
            if (Object.keys(newIds).length === 1 && Object.keys(oldIds).length === 1) {
              k = Object.keys(oldIds)[0];
              v[1] = index[k][1];
              if (v[0].__assignedID && index[k][0].__assignedID) {
                v[0].id = k;
              }
            } else {
              v[1] = index[k][1];
            }
          }
          index[k] = v;
          oldKeys.delete(k);
        }
        results = [];
        for (k in oldKeys) {
          results.push(delete index[k]);
        }
        return results;
      }

      analyzeInputs(dom, context) {
        var l, len, node, ref1, results;
        ref1 = find(dom, "input, textarea, button, [data-path]");
        results = [];
        for (l = 0, len = ref1.length; l < len; l++) {
          node = ref1[l];
          results.push(((node) => {
            var fullpath, path, ref2;
            if (fullpath = node.getAttribute('data-path-full')) {
              path = stringToLocation(node.getAttribute('data-path-full'));
              if (node.getAttribute('data-bind-keypress')) {
                node.on('keydown', function(e) {
                  var base, ref2;
                  if (!((ref2 = keyCode(e)) === 'C-r' || ref2 === 'C-J')) {
                    e.preventDefault();
                    e.stopPropagation();
                    return typeof (base = context.handler).keyPress === "function" ? base.keyPress(e.originalEvent) : void 0;
                  }
                });
              }
              if (((ref2 = node.type) === 'button' || ref2 === 'submit') || node.type !== 'text') {
                // using onmousedown, onclick, path, and @pressed because
                // the view can render out from under the button if focus changes
                // which replaces the button with ta new one in the middle of a click event
                node.onmousedown = (evt) => {
                  return this.pressed = path;
                };
                return node.onclick = (evt) => {
                  var base, err, newValue, oldValue, v;
                  if (this.pressed === path || evt.detail === 0) {
                    this.pressed = false;
                    newValue = (function() {
                      if (v = node.getAttribute('value')) {
                        try {
                          return JSON.parse(v);
                        } catch (error) {
                          err = error;
                          return v;
                        }
                      } else if (typeof (oldValue = this.getPath(context.top, context.top.contents, path)) === 'boolean') {
                        return newValue = !oldValue;
                      }
                    }).call(this);
                    if (newValue) {
                      this.setValueFromUser(node, evt, dom, context, path, newValue);
                    } else {
                      if (typeof (base = context.handler).clickButton === "function") {
                        base.clickButton(evt);
                      }
                    }
                    return this.runRefreshQueue();
                  }
                };
              } else {
                return node.onchange = (evt) => {
                  var ownerPath, ownerPathString;
                  ownerPathString = evt.srcElement.closest('[data-location]').getAttribute('data-location');
                  ownerPath = stringToLocation(ownerPathString);
                  return this.setValueFromUser(node, evt, dom, context, path, node.value);
                };
              }
            }
          })(node));
        }
        return results;
      }

      setValueFromUser(node, evt, dom, context, path, value) {
        var base, json, ownerPath, ownerPathString;
        ownerPathString = node.closest('[data-location]').getAttribute('data-location');
        ownerPath = stringToLocation(ownerPathString);
        json = this.getPath(context.top, context.top.contents, ownerPath);
        this.setPath(context.top, context.top.contents, path, value);
        if (typeof (base = context.handler).changedValue === "function") {
          base.changedValue(evt, value);
        }
        this.valueChanged(evt.srcElement.closest('[data-top]'), evt.srcElement);
        return this.queueRefresh(() => {
          var l, len, namespace, ref1, results;
          ref1 = queryAll(`[data-location='${ownerPathString}']`);
          results = [];
          for (l = 0, len = ref1.length; l < len; l++) {
            node = ref1[l];
            namespace = node.getAttribute('data-namespace');
            results.push(this.render(node, json, Object.assign({}, context, {
              namespace: namespace,
              location: ownerPath
            })));
          }
          return results;
        });
      }

      populateInputs(dom, json, context) {
        var fullpath, l, len, location, node, path, ref1, setSome;
        if (dom.getAttribute('data-location')) {
          setSome = false;
          location = stringToLocation(dom.getAttribute('data-location'));
          ref1 = find(dom, "[data-path]");
          for (l = 0, len = ref1.length; l < len; l++) {
            node = ref1[l];
            if (node.closest('[data-location]') === dom) {
              path = node.getAttribute('data-path').split('.');
              fullpath = locationToString([...location, ...path]);
              if (node.type === 'text') {
                node.setAttribute('value', this.getPath(context.top, json, path));
              }
              node.setAttribute('data-path-full', fullpath);
              setSome = true;
            }
          }
          return setSome;
        }
      }

      valueChanged(dom, source) {
        var fullpath, l, len, node, ref1, results, value;
        value = source.value;
        fullpath = source.getAttribute('data-path-full');
        ref1 = find(dom, `[data-path-full='${fullpath}']`);
        results = [];
        for (l = 0, len = ref1.length; l < len; l++) {
          node = ref1[l];
          if (node !== source) {
            results.push(node.value = value);
          }
        }
        return results;
      }

      getPath(doc, json, location) {
        var i, l, len;
        location = resolvePath(doc, location);
        for (l = 0, len = location.length; l < len; l++) {
          i = location[l];
          json = json[i];
        }
        return json;
      }

      setPath(document, json, location, value) {
        var i, index, l, last, lastI, len, newJson, results;
        last = json;
        lastI = 0;
        location = resolvePath(document, location);
        results = [];
        for (index = l = 0, len = location.length; l < len; index = ++l) {
          i = location[index];
          if (index + 1 === location.length) {
            if (value.type != null) {
              this.adjustIndex(document.index, json, json[i], value);
            } else {
              newJson = Object.assign({}, last);
              newJson[lastI] = value;
              this.adjustIndex(document.index, last, json, newJson);
            }
            results.push(json[i] = value);
          } else {
            last = json;
            lastI = i;
            results.push(json = json[i]);
          }
        }
        return results;
      }

      defView(context, namespace, type, def) {
        return context.views[namespace][type] = compile(def);
      }

    };
    Handlebars.registerHelper('view', function(item, namespace, options) {
      var context, data, i, l, len, location, node;
      if (typeof item !== 'string') {
        throw new Error("View must be called with one or two strings");
      }
      if (options == null) {
        options = namespace;
        namespace = null;
      }
      location = stringToLocation(item);
      context = options.data.context;
      context = Object.assign({}, context, {
        location: [...context.location, ...location]
      });
      if (namespace) {
        context.namespace = namespace;
      }
      data = this;
      for (l = 0, len = location.length; l < len; l++) {
        i = location[l];
        data = data[i];
      }
      if (data) {
        node = options.data.metadom.baseRender(parseHtml('<div></div>'), data, context);
        if (node.nodeType === 1) {
          return node.outerHTML;
        } else {
          return node.data;
        }
      } else {
        return "";
      }
    });
    // Command processor clients (if using client/server)
    messages = {
      batch: function(con, items) {
        var item, l, len;
        con.batchLevel++;
        for (l = 0, len = items.length; l < len; l++) {
          item = items[l];
          handleMessage(con, item);
        }
        return con.batchLevel--;
      },
      document: function(con, doc) {
        con.document = doc;
        con.context.top = doc;
        con.dom = con.md.render(con.dom, doc, con.context);
        return con.context.views = con.document.compiledViews;
      },
      set: function(con, path, value) {
        con.md.setPath(con.document, con.document.contents, path, value);
        if (value.type == null) {
          path.pop();
        }
        con.changedJson.add(locationToString(path));
        return path;
      },
      delete: function(con, path) {
        var i, index, l, last, len, obj, results;
        obj = con.document.contents;
        last = obj;
        results = [];
        for (index = l = 0, len = path.length; l < len; index = ++l) {
          i = path[index];
          if (index + 1 === path.length) {
            obj = Object.assign({}, obj);
            if (typeof i === 'number') {
              obj.splice(i, 1);
            } else {
              delete obj[i];
            }
            path.pop();
            con.md.setPath(con.document, con.document.contents, path, obj);
            if (obj.type == null) {
              path.pop();
            }
            con.changedJson.add(locationToString(path));
            break;
          } else {
            last = obj;
            results.push(obj = obj[i]);
          }
        }
        return results;
      },
      insert: function(con, path, json) {
        var i, index, l, len, obj, results;
        obj = con.document.contents;
        results = [];
        for (index = l = 0, len = path.length; l < len; index = ++l) {
          i = path[index];
          if (index + 2 === path.length) {
            if (typeof i === 'number') {
              obj.splice(i, 0, null);
            }
            con.md.setPath(con.document, con.document.contents, path, json);
            path.pop();
            while (con.md.getPath(con.document, con.document.contents, path).type == null) {
              path.pop();
            }
            con.changedJson.add(locationToString(path));
            break;
          } else {
            results.push(obj = obj[i]);
          }
        }
        return results;
      },
      defView: function(con, namespace, type, def) {
        return con.md.defView(con.context, namespace, type, def);
      }
    };
    // #Change handler
    handleChanges = function(ctx) {
      var path, ref1;
      if (ctx.batchLevel === 0) {
        ref1 = ctx.changedJson;
        for (path of ref1) {
          ctx.md.rerender(ctx.md.getPath(ctx.doc, ctx.doc.contents, stringToLocation(path)), ctx, function(dom) {
            if (dom.getAttribute('data-top') != null) {
              return ctx.setTopFunc(dom);
            }
          });
        }
        ctx.changedJson.clear();
        return ctx.md.runRefreshQueue();
      }
    };
    change = function(ctx, path) {
      ctx.changedJson.add(locationToString(path));
      if (ctx.batchLevel === 0) {
        return handleChanges(ctx);
      }
    };
    initChangeContext = function(md, ctx, doc, setTopFunc) {
      ctx.batchLevel = 0;
      ctx.changedJson = new Set();
      ctx.md = md;
      ctx.doc = doc;
      return ctx.setTopFunc = setTopFunc;
    };
    // `batch(CTX, FUNC)` executes FUNC, queuing up re-rendering requests and then processing the requests all at once after FUNC finishes.
    batch = function(ctx, func) {
      if (typeof ctx.batchLevel === 'number') {
        ctx.batchLevel++;
        try {
          return func();
        } finally {
          ctx.batchLevel--;
          handleChanges(ctx);
        }
      } else {
        return func();
      }
    };
    // #Local Code
    isDocPathSym = Symbol("isDocPath");
    partsSym = Symbol("parts");
    syms = [isDocPathSym, partsSym];
    // `isDocPath(obj)` returns true if the object is a docPath
    isDocPath = function(obj) {
      return obj[isDocPathSym];
    };
    // `docPathParts(docp)` returns the "parts" you used to create the doc path: [md, ctx, path]
    docPathParts = function(docp) {
      return docp[partsSym];
    };
    // `docPathParent(docp)` returns a parent DocPath for docp (i.e. a DocPath without the last path element)
    docPathParent = function(docp) {
      var ctx, md, path;
      [md, ctx, path] = docPathParts(docp);
      if (!path.length) {
        return docp;
      } else {
        return docPath(md, ctx, path.slice(0, -1));
      }
    };
    // `docPathValue(docp)` returns the value for the DocPath
    docPathValue = function(docp) {
      var ctx, md, path;
      [md, ctx, path] = docPathParts(docp);
      return docValue(md, ctx, path);
    };
    // `docPath(md, ctx, path = [])` creates a DocPath
    docPath = function(md, ctx, path = []) {
      return new Proxy({}, {
        get: function(target, name) {
          if (name === isDocPathSym) {
            return true;
          } else if (name === partsSym) {
            return [md, ctx, path];
          } else if (name === 'toString()') {
            return function() {
              return printDocPath(md, ctx, path);
            };
          } else {
            return docValue(md, ctx, [...path, name]);
          }
        },
        set: function(target, name, value) {
          if (!(indexOf.call(syms, name) >= 0)) {
            path = [...path, name];
            md.setPath(ctx.top, ctx.top.contents, path, value);
            return change(ctx, resolvePath(ctx.top, path));
          }
        }
      });
    };
    docValue = function(md, ctx, path, value) {
      var val;
      if (value === void 0) {
        val = md.getPath(ctx.top, ctx.top.contents, path);
        if (val === void 0) {
          return val;
        } else {
          return docValue(md, ctx, path, md.getPath(ctx.top, ctx.top.contents, path));
        }
      } else if (Array.isArray(value)) {
        return docPath(md, ctx, path);
      } else if (typeof value === 'object') {
        return docPath(md, ctx, path);
      } else {
        return value;
      }
    };
    eventPaths = function(md, ctx, evt) {
      var fullPath, node, obj, objPath, path, value;
      node = evt.srcElement;
      fullPath = stringToLocation(node.getAttribute('data-path-full'));
      path = stringToLocation(node.getAttribute('data-path'));
      objPath = stringToLocation(node.closest('[data-location]').getAttribute('data-location'));
      obj = md.getPath(ctx.top, ctx.top.contents, objPath);
      value = md.getPath(ctx.top, ctx.top.contents, [...objPath, ...path]);
      return [fullPath, obj, objPath, path, value];
    };
    dispatchClick = function(md, ctx, handlers, evt) {
      var docp, fullPath, obj, objPath, path, value;
      [fullPath, obj, objPath, path, value] = eventPaths(md, ctx, evt);
      docp = docPath(md, ctx, fullPath);
      return batch(ctx, function() {
        var name1, ref1, ref2;
        if (typeof handlers[name1 = [obj.type, locationToString(path), "click"].join(',')] === "function") {
          handlers[name1](docp, obj, objPath, path, value, evt);
        }
        return (ref1 = handlers[obj.type]) != null ? (ref2 = ref1[locationToString(path)]) != null ? typeof ref2.click === "function" ? ref2.click(docp, obj, objPath, path, value, evt) : void 0 : void 0 : void 0;
      });
    };
    dispatchKey = function(md, ctx, handlers, evt) {
      var docp, fullPath, obj, objPath, path, value;
      [fullPath, obj, objPath, path, value] = eventPaths(md, ctx, evt);
      docp = docPath(md, ctx, fullPath);
      return batch(ctx, function() {
        var name1, ref1, ref2;
        if (typeof handlers[name1 = [obj.type, locationToString(path), "key"].join(',')] === "function") {
          handlers[name1](docp, obj, objPath, path, value, evt);
        }
        return (ref1 = handlers[obj.type]) != null ? (ref2 = ref1[locationToString(path)]) != null ? typeof ref2.key === "function" ? ref2.key(docp, obj, objPath, path, value, evt) : void 0 : void 0 : void 0;
      });
    };
    dispatchSet = function(md, ctx, handlers, evt) {
      var docp, fullPath, obj, objPath, path, value;
      [fullPath, obj, objPath, path, value] = eventPaths(md, ctx, evt);
      docp = docPath(md, ctx, fullPath);
      return batch(ctx, function() {
        var name1, ref1, ref2;
        if (typeof handlers[name1 = [obj.type, locationToString(path), "set"].join(',')] === "function") {
          handlers[name1](docp, obj, objPath, path, value, evt);
        }
        return (ref1 = handlers[obj.type]) != null ? (ref2 = ref1[locationToString(path)]) != null ? typeof ref2.set === "function" ? ref2.set(docp, obj, objPath, path, value, evt) : void 0 : void 0 : void 0;
      });
    };
    // patternHandler(MD, CTX, HANDLERS) returns an event handler and makes it easy to define event handlers for types and paths

    // HANDLERS specify event handlers in one of two ways (you can mix them, using whichever is more convenient):
    // - "TYPE,FIELD,EVENT": (OBJ, PATH, KEY, VALUE, EVT)=> ...
    // - TYPE: {FIELD: {EVENT: (OBJ, PATH, KEY, VALUE, EVT)=> ...}}
    patternHandler = function(md, ctx, handlers) {
      return ctx.handler = {
        clickButton: function(evt) {
          return dispatchClick(md, ctx, handlers, evt);
        },
        changedValue: function(evt) {
          return dispatchSet(md, ctx, handlers, evt);
        }
      };
    };
    // #Client Code

    // Connect to WebSocket server
    handleMessage = function(con, [cmd, ...args]) {
      var path, ref1;
      messages[cmd](con, ...args);
      if (con.batchLevel === 0) {
        ref1 = con.changedJson;
        for (path of ref1) {
          con.md.rerender(con.md.getPath(con.document, con.document.contents, stringToLocation(path)), con.context, function(dom) {
            if (dom.getAttribute('data-top') != null) {
              return con.dom = dom;
            }
          });
        }
        return con.changedJson.clear();
      }
    };
    connect = function(con, url) {
      var ws;
      con.md = new JSONMetadom(query('#top'));
      con.batchLevel = 0;
      con.changedJson = new Set();
      con.dom = query('#top');
      con.context = Object.assign({}, con.context, {
        top: null,
        handler: {
          keyPress: function(evt) {
            var key;
            if (key = keyCode(evt)) {
              return ws.send(JSON.stringify(['key', key, stringToLocation(evt.currentTarget.closest('[data-location]').getAttribute('data-location'))]));
            }
          },
          clickButton: function(evt) {
            var name, path;
            path = stringToLocation(evt.currentTarget.getAttribute('data-path-full'));
            name = path.pop();
            return ws.send(JSON.stringify(['click', name, path]));
          },
          changedValue: function(evt, value) {
            var node;
            node = evt.currentTarget;
            return ws.send(JSON.stringify(['set', stringToLocation(node.getAttribute('data-path-full')), value != null ? value : node.value]));
          }
        }
      });
      ws = con.socket = new WebSocket(url);
      ws.onmessage = function(msg) {
        return handleMessage(con, JSON.parse(msg.data));
      };
      return ws;
    };
    Object.assign(JSONMetadom, {locationToString, stringToLocation, closestLocation, query, queryAll, find, parseHtml, keyCode, connect, messages, docPath, docPathValue, isDocPath, docPathParts, docPathParent, initChangeContext, batch, change, patternHandler, dispatchClick, dispatchKey, dispatchSet});
    return JSONMetadom;
  });

}).call(this);

//# sourceMappingURL=jsonmetadom.js.map
